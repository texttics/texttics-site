<!doctype html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="https://pyscript.net/releases/2024.9.1/core.css" />
  <script type="module" src="https://pyscript.net/releases/2024.9.1/core.js"></script>

  <py-config type="toml">
    packages = ["numpy"]
  </py-config>

  <style>
    body { font: 16px/1.4 system-ui, sans-serif; max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
    textarea { width: 100%; height: 220px; box-sizing: border-box; }
    .stats { display: grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap: .8rem; margin-top: 1rem; }
    .card { padding: .8rem 1rem; border: 1px solid #ddd; border-radius: 10px; }

    /* Styles for the formatted output area */
/* Styles for the formatted output area */
    h2 { margin-top: 2rem; }

    /* NEW: This is now the main grid container */
    #formatted-output {
      display: grid;
      /* 2 columns: label (auto-width) and text (takes rest of space) */
      grid-template-columns: auto 1fr;
      /* Add space between the label and the text box */
      column-gap: 1.5rem;
      /* Add space between each percentile row */
      row-gap: 0.5rem; /* Reduced this gap */
    }

    /* NEW: Style for the label (left column) */
    .percentile-label {
      font-family: monospace;
      font-size: 0.9rem;
      color: #333;
      /* Aligns the label text to the top of its row */
      padding-top: 1rem; 
    }
    
    /* NEW: Style for the text block (right column) */
    .percentile-text-block {
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 1rem;
      line-height: 1.6;
      background: #fdfdfd;
      /* This adds the underline you wanted, visually separating it */
      border-bottom: 2px solid #aaa; 
      margin-bottom: 1rem; /* Adds space after the underline */
    }
  </style>
</head>
<body>
  <h1>Word Counter (client-side Python)</h1>
  
  <textarea id="text" py-input="update_all" placeholder="Paste or type here..."></textarea>
  
  <div class="stats" id="stats"></div>

  <h2>Text Dissected by Word Count Decile</h2>
  <div id="formatted-output" class="formatted-text"></div>

  <script type="py">
from pyscript import document
import re
import numpy as np

WORD_RE = re.compile(r"[A-Za-zÀ-ÖØ-öø-ÿ0-9]+(?:[-'][A-Za-zÀ-ÖØ-öø-ÿ0-9]+)*")
SENT_SPLIT_RE = re.compile(r'([.!?]+(?:\s|$))')

def compute_stats(t: str):
    words = WORD_RE.findall(t)
    sentences_for_count = SENT_SPLIT_RE.split(t)
    num_sentences = sum(1 for s in sentences_for_count if s.strip() and not SENT_SPLIT_RE.match(s))
    if not t.strip():
        num_sentences = 0

    return {
        "Words": len(words),
        "Characters": len(t),
        "Characters (no spaces)": len("".join(ch for ch in t if not ch.isspace())),
        "Sentences": num_sentences,
        "Paragraphs": sum(1 for p in t.splitlines() if p.strip()),
        "Reading time": f"{(len(words)/200)*60:.0f} s" if words else "0 s",
    }

def get_word_count(sentence_str):
    return len(WORD_RE.findall(sentence_str))

# *** NEW: Completely rewritten to dissect text by word count deciles ***
def format_text(t: str):
    if not t.strip():
        return ""

    # --- 1. Get all sentences and their word counts ---
    split_text = SENT_SPLIT_RE.split(t)
    sentences = []
    total_words = 0
    for i in range(0, len(split_text) - 1, 2):
        sentence_text = split_text[i] + (split_text[i+1] or '')
        if sentence_text.strip():
            count = get_word_count(sentence_text)
            sentences.append({'text': sentence_text, 'count': count})
            total_words += count
            
    # Add any trailing text
    if len(split_text) % 2 == 1 and split_text[-1].strip():
        count = get_word_count(split_text[-1])
        sentences.append({'text': split_text[-1], 'count': count})
        total_words += count

    if not sentences:
        return t

    # --- 2. Define decile cutoffs based on total word count ---
    # We create 9 cutoffs: 10%, 20%, ..., 90%
    decile_cutoffs = [(total_words * (i / 10.0)) for i in range(1, 10)]
    
    labels = [
        "0-10%", "10-20%", "20-30%", "30-40%", "40-50%",
        "50-60%", "60-70%", "70-80%", "80-90%", "90-100%"
    ]
    
    # --- 3. Build HTML by iterating through sentences ---
    html_output = ""
    running_word_count = 0
    decile_index = 0 # This is the index for labels AND cutoffs

    # Start the very first paragraph
    html_output += f'<p class="percentile-group"><strong>{labels[decile_index]}</strong>'
    
    for s in sentences:
        sentence_text = s['text']
        sentence_count = s['count']

        # Check if adding this sentence *crosses* the *next* boundary
        # We check < 9 because there are 9 cutoffs (decile_cutoffs[0] to decile_cutoffs[8])
        if decile_index < 9 and (running_word_count + sentence_count) > decile_cutoffs[decile_index]:
            # It crosses the boundary. End the current paragraph.
            html_output += '</p>'
            
            # Move to the next decile
            decile_index += 1
            
            # Start the new paragraph with the new label
            html_output += f'<p class="percentile-group"><strong>{labels[decile_index]}</strong>'
            
        # Add the sentence text to the current paragraph
        html_output += sentence_text + ' '
        running_word_count += sentence_count

    # Close the final paragraph tag
    html_output += '</p>'
    
    return html_output.replace("<p></p>", "") # Clean up any empty paragraphs


def update_all(event=None):
    t = document.getElementById("text").value
    
    # 1. Update the stats cards
    stats = compute_stats(t)
    stats_html = "".join(f'<div class="card"><strong>{k}</strong><div>{v}</div></div>'
                         for k,v in stats.items())
    document.getElementById("stats").innerHTML = stats_html
    
    # 2. Update the formatted text output
    formatted_html = format_text(t)
    document.getElementById("formatted-output").innerHTML = formatted_html

# Run once on load
update_all()
  </script>
</body>
</html>
